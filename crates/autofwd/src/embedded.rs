//! Embedded agent binaries for different architectures.
//!
//! This module contains compressed agent binaries that are embedded at compile time.
//! The binaries are decompressed on demand when deploying to a remote server.

use std::io::Read;

/// Embedded agent binary with its hash.
pub struct EmbeddedAgent {
    /// Compressed binary data (zstd).
    pub compressed: &'static [u8],
    /// First 12 characters of the BLAKE3 hash.
    pub hash: &'static str,
}

impl EmbeddedAgent {
    /// Check if this is a real agent binary (not a stub).
    /// Real binaries are at least 50KB compressed; stubs are just a few bytes.
    pub fn is_available(&self) -> bool {
        self.compressed.len() > 50_000
    }
}

// Agent binaries embedded at compile time.
// These are generated by the build script and placed in target/agents/

/// x86_64 Linux (musl) - most common servers
pub const AGENT_X86_64: EmbeddedAgent = EmbeddedAgent {
    compressed: include_bytes!("../../../target/agents/x86_64-unknown-linux-musl.zst"),
    hash: env!("AGENT_HASH_X86_64"),
};

/// aarch64 Linux (musl) - ARM64 servers (AWS Graviton, etc.)
pub const AGENT_AARCH64: EmbeddedAgent = EmbeddedAgent {
    compressed: include_bytes!("../../../target/agents/aarch64-unknown-linux-musl.zst"),
    hash: env!("AGENT_HASH_AARCH64"),
};

/// armv7 Linux (musl) - ARM32 (Raspberry Pi, etc.)
pub const AGENT_ARMV7: EmbeddedAgent = EmbeddedAgent {
    compressed: include_bytes!("../../../target/agents/armv7-unknown-linux-musleabihf.zst"),
    hash: env!("AGENT_HASH_ARMV7"),
};

impl EmbeddedAgent {
    /// Decompress the agent binary.
    pub fn decompress(&self) -> anyhow::Result<Vec<u8>> {
        if !self.is_available() {
            anyhow::bail!("Agent binary not available (stub only)");
        }

        let mut decoder = zstd::Decoder::new(self.compressed)?;
        let mut decompressed = Vec::new();
        decoder.read_to_end(&mut decompressed)?;
        Ok(decompressed)
    }

    /// Get the remote filename for this agent (includes hash for versioning).
    pub fn remote_filename(&self) -> String {
        format!("autofwd-agent-{}", self.hash)
    }
}

/// Get the embedded agent for the given architecture string (from `uname -m`).
pub fn agent_for_arch(arch: &str) -> Option<&'static EmbeddedAgent> {
    match arch.trim() {
        "x86_64" | "amd64" => Some(&AGENT_X86_64),
        "aarch64" | "arm64" => Some(&AGENT_AARCH64),
        "armv7l" | "armv7" | "armhf" => Some(&AGENT_ARMV7),
        _ => None,
    }
}

/// Check if any agents are available (not stubs).
#[allow(dead_code)]
pub fn agents_available() -> bool {
    AGENT_X86_64.is_available() || AGENT_AARCH64.is_available() || AGENT_ARMV7.is_available()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_agent_for_arch() {
        assert!(agent_for_arch("x86_64").is_some());
        assert!(agent_for_arch("amd64").is_some());
        assert!(agent_for_arch("aarch64").is_some());
        assert!(agent_for_arch("arm64").is_some());
        assert!(agent_for_arch("armv7l").is_some());
        assert!(agent_for_arch("unknown").is_none());
    }

    #[test]
    fn test_remote_filename() {
        let agent = &AGENT_X86_64;
        let filename = agent.remote_filename();
        assert!(filename.starts_with("autofwd-agent-"));
        assert_eq!(filename.len(), "autofwd-agent-".len() + 12);
    }
}
